# 序

本篇文章是《编程珠玑》第二版的学习笔记，学习的过程主要以摘抄为主，并且加入自己的见解，目的是做到简浅易懂，方便记忆与理解。由于笔者的学习与工作原因，博客的笔记会不定时更新，如果想看最的内容，请移步到<a href="https://github.com/laneston/Note">github实时更新</a>查看。


# 目录

<a href="#capture1">第一章</a><br>
- <a href="#The right question">正确的问题</a>
- <a href="#Bitmap data structure">位图数据结构</a>
- <a href="#Multi pass algorithm">多趟算法</a>
- <a href="#Time-Space compromise and win-win">时间-空间折中与双赢</a>
- <a href="#Simple design">简单的设计</a>

<a href="#capture2">第二章</a><br>
- <a href="#Three questions">三个问题</a>
- <a href="Binary searchs">二分搜索</a>
- <a href="Basic operation">基本操作</a>




<h1 id="capture1">第一章</h1>

<h3 id="The right question">正确的问题</h3>

准确的问题描述会使问题的关键暴露出来，使得问题易于解决。

<h3 id="Bitmap data structure">位图数据结构</h3>

位图结构常用于解决内存不足的问题。

使用1个位来表示一个整数，如果对应位的值为真，则表示这个数存在。譬如，16Byte内存一共有128个bit。我们可以用16个字节的内存空间来记录0-127。

如果我们要在32位单片机上存储范围为0-99999999的数据，每个数值会随机出现或消失，且每个数值不会重复出现。按照常用的办法，我们需要开辟1×10^8个int类型的内存空间，占用了4×10^8字节，约为382MB。如果我们用1×10^8个bit来存储这些数据，我们只需1.25×10^7个字节的空间，节省了3.875×10^8个字节的空间。

但这种算法是十分有局限性的，如果数据会重复出现，我们需要用有限定义域内的键作为一个表项更复杂的表格的索引。譬如每个数据最多出现10次，需要用4个bit来统计出现的次数，但所用内存因此扩大了4倍。

<h3 id="Multi pass algorithm">多趟算法</h3>

因为内存空间的不足，算法多趟输入数据，每次完成一步。

<h3 id="Time-Space compromise and win-win">时间-空间折中与双赢</h3>

编程文献和理论中充斥着时间-空间的折中：通过使用更多的时间，可以减少程序所需的空间。

<h3 id="Simple design">简单的设计</h3>

简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。


<h1 id="capture2">第二章</h1>

算法在实际编程当中作为完成重要任务的方法和技术对软件系统影响很大，减少开发时间，同事使执行速度更快。

<h3 id="Three questions">三个问题</h3>

1. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数（在文件中至少确实一个这样的数——为什么？）。在具有足够内存的情况下，如何解决该问题？如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题？
2. 将一个n元一维向量向左旋转（循环位移）i个位置。例如，当n=8且i=3时，向量abcdefgh旋转为defghabc。简单的代码使用一个n元的中间向量在n步内完成该工作。你能否仅使用数十个额外字节的存储空间，在正比于n的时间内完成向量的旋转？
3. 给定一个英语字典，找出其中的所有变位词集合。例如，“pots”“stop”和“tops”互为变位词，因为每一个单词都可以通过改变其他单词中字幕的顺序来得到。

<h3 id="Binary search">二分搜索</h3>

二分搜索通过重复探索当前范围的中点来定位对象。如果一次探测没有找到该对象，那么我们将当前范围减半，然后继续下一次探测。当找到所需要的对象或范围为空时停止。譬如搜索的整数位于1到n之间，那么可以在log2^n次之内可以获得结果。

为了采用二分搜索技术，就必须定义一个范围，在该范围内表示元素的方式以及用来确定哪一半范围存在缺失整数的探测方法。

问题1中，32位整数不超过40亿个，而32位整数，最多包含了2^32位整数，也就是4294967296个，所以必然会缺少整数。如果内存充足，可以采用位图思想来解决这个问题，只需使用536870912个字节就可以表示看到的整数。如果内存不足，可以采用以下方法解决这个问题：

  1. 比较所有数据的最高位，如果最高位为1，则将数保存在A堆，如果最高位为0，则将数保存在B堆。如果A堆的数比B堆的数少，说明缺少的数在A堆，反之亦然。
  2. 然后比较所有数据的次高位，如果最高位为1，则将数保存在C堆，如果最高位为0，则将数保存在D堆。如果A堆的数比B堆的数少，说明缺少的数在A堆，反之亦然。
  3. 重复以上步骤，以此比较每个位。

算法复杂度位O(n)

<h3 id="Basic operation">基本操作</h3>

问题B仅使用几十字节的额外空间将一个n元向量x在正比于n的时间内向左旋转i个位置。在一些编程语言中，该功能是向量的一个基本操作。更重要的是，旋转操作对应于交换相邻的不同大小的内存块：每当拖动文件中的一块文字到其他地方时，就会要求程序交换两块内存中的内容。

**方法一**

1. 将x的前i个元素复制到一个临时数组中；
2. 将余下的n-i个元素向左移动i个位置；
3. 将最初的i个元素总临时数组中复制到x中余下的位置。

这种方法的 **缺点** 是使用了i个额外的位置会产生过大的存储空间。

**方法二**

1. 定义一个函数将x向左旋转一个位置；
2. 调用该函数i次。

这种方法的 **缺点** 是产生过多的时间消耗。

**方法三**

要在有限的资源内解决该问题，显然需要更复杂的程序。

<img src="https://github.com/laneston/Pictures/blob/master/Post-Programming%20Pearls%20Note/complex.jpg" width="50%" height="50%">

1. 移动x[0]到临时变量t，然后移动x[i]到x[0]，x[2i]到x[i]，x[3i]到x[2i]...以此类推，直至将x[ai]移动到x[(a-1)i]。
2. 将t移动至x[ai];

以上两步就是这个算法的一趟。

这个算法的元素移动方式有点类似排序算法中的冒泡排序，如果该过程没有移动全部元素，就从x[1]开始再次进行移动，直至所有的元素都已经移动为止。

